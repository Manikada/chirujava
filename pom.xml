
1. Version: Specifies which version of the __ file format you're using. Each version comes with its own set of features.
version: '3.8'
 
2. Services: This section defines all the containers you want to run for your application. Each service represents a container (like a web server or database).
Each service includes:
o Image: The Docker image to use.
o Ports: Ports to map between the container and your host machine.
o Environment: Environment variables required by the service.
o Dependencies: Which other services a container depends on.
Example:
 
3. Networks: Define networks to allow different services to communicate with each other. Docker Compose automatically creates a default network if not specified.
 
4. Volumes: Used for persistent storage, allowing data to persist even after the container stops or is removed.
 
Example Docker Compose File (Simple)
Here’s a basic example of a Docker Compose file that runs WordPress and MySQL together:
version: '3.8'  # Docker Compose file format version



services:
  wordpress:  # WordPress service
    image: wordpress:latest
    ports:
      - "8080:80"  # Map port 80 of the container to port 8080 of the host
    environment:
      WORDPRESS_DB_HOST: db:3306  # Database host
      WORDPRESS_DB_USER: wordpress
      WORDPRESS_DB_PASSWORD: wordpress
      WORDPRESS_DB_NAME: wordpress
    depends_on:
      - db  # Ensures the db service starts first
 
  db:  # MySQL service
    image: mysql:5.7
    environment:
      MYSQL_ROOT_PASSWORD: rootpassword
      MYSQL_DATABASE: wordpress
      MYSQL_USER: wordpress
      MYSQL_PASSWORD: wordpress
 
How to Run It
To run a multi-container setup like the one above:
1. Save the file as docker-compose.yml.
                Or
docker-compose.yaml
2. To Start the compose
 
docker-compose up –d
 
3. To stop the containers
       docker-compose down
4. To scale the container
 
docker-compose up --scale <service name>=2 -d
 
1.Define and run multiple interdependent services
 
Task:
I. Create a new folder compose-lab
Inside it, create a file docker-compose.yml with the following content:
 
version: "3.9"
services:
  web:
    image: nginx:latest
    ports:
      - "8080:80"
 
  db:
    image: postgres:15
    environment:
      POSTGRES_USER: demo
      POSTGRES_PASSWORD: demo
      POSTGRES_DB: demo_db
 
II. Run the setup:
 
docker compose up -d
 
III. Open your browser and visit: http://localhost:8080.
 
IV. Expected Output:
 
Nginx welcome page is displayed.
db container runs in the background.
 
2.Write and interpret docker-compose.yml files
Task:
I. Modify docker-compose.yml to add a Redis cache:
 
  redis:
    image: redis:alpine
 
II. Add a depends_on so web waits for Redis:
  web:
    image: nginx:latest
    ports:
      - "8080:80"
    depends_on:
      - redis
 
III. Restart the setup:
docker compose up -d
docker compose ps
 
IV. Expected Output:
 
Three services (web, db, redis) are listed as running.
 
3.Deploy across different machines
Task:
I. Zip your compose-lab folder.
 
Transfer it to another machine with Docker Compose installed.
 
II. Run:
docker compose up -d
 
Check that Nginx and Postgres work there as well.
 
III. Expected Output:
The same services run on the new machine without changes.
 
4.Networking and persistent storage
Task:
I. Update your docker-compose.yml to add a custom network and volume:
 
networks:
  app-net:
 
volumes:
  db-data:
 
services:
  web:
    image: nginx:latest
    ports:
      - "8080:80"
    networks:
      - app-net
    depends_on:
      - db
 
  db:
    image: postgres:15
    environment:
      POSTGRES_USER: demo
      POSTGRES_PASSWORD: demo
      POSTGRES_DB: demo_db
    volumes:
      - db-data:/var/lib/postgresql/data
    networks:
      - app-net
 
II. Run:
docker compose up -d
III. Insert some data into Postgres (optional with psql).
IV. Remove containers:
docker compose down
V. Start again:
docker compose up -d
VI. Expected Output:
Database data persists across restarts.
Services communicate via the app-net network using service names.
 
5.Faster iteration during development
Task:
I. Create a simple Flask app in app.py:
 
from flask import Flask
app = Flask(__name__)
@app.route("/")
def home():
    return "Hello from Flask + Docker!"
if __name__ == "__main__":
    app.run(host="0.0.0.0", port=5000)
 
II. Add a Dockerfile in the same folder:
 
FROM python:3.10-slim
WORKDIR /app
COPY app.py /app/
RUN pip install flask
CMD ["python", "app.py"]
 
III. Update docker-compose.yml:
  version: "3.9"
services:
  web:
    build: .
    container_name: flask_app
    ports:
      - "5000:5000"
IV. Run:
docker compose up --build
Visit http://localhost:5000.
Change the return text in app.py (e.g., "Hello Docker Compose!").
V. Rebuild:
docker compose up --build
VI. Expected Output:
New message appears instantly after rebuild.
 














 <!doctype html>
<html>
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Simple Freelance Job Board</title>
  </head>
  <body>
    
pipeline {
agent any  // Agent: Defines the machine (or slave) that runs the tasks 
   tools{
        maven 'MAVEN-HOME'
    }
    stages {         //The script is divided into stages, each representing a specific step, like building,
        stage('git repo & clean') {
            steps {
                //bat "rmdir  /s /q mavenjava"
                bat "git clone provide your github link"
                bat "mvn clean -f mavenjava"
            }
        }
        stage('install') {
            steps {
                bat "mvn install -f mavenjava" #project name#
            }
        }
        stage('test') {
            steps {
 bat "mvn test -f mavenjava"
            }
        }
        stage('package') {
            steps {
                bat "mvn package -f mavenjava"
            }
        }
    }
}


minikube start --driver=hyperv

minikube start --driver=docker
minikube start
kubectl create deployment mynginx --image=nginx

kubectl expose deployment mynginx --type=NodePort --port=80 --target-port=80
kubectl scale deployment mynginx --replicas=4
kubectl get service myngnix
kubectl port-forward svc/mynginx 8081:80

kubectl delete deployment mynginx
kubectl delete service mynginx


   

Pull the Nagios Docker Image
Open a terminal and run:

docker pull jasonrivers/nagios:latest
docker run --name nagiosdemo -p 8888:80 jasonrivers/nagios:latest
docker stop nagiosdemo
docker rm nagiosdemo

    
    docker pull redis
docker run --name my-redis -d redis
docker exec -it my-redis redis-cli
SET name "Alice"
GET name
docker stop my-redis
docker rm my-redis 

    

 Create a folder like C:\DockerProjects\Redis.
o Open Git Bash and navigate to the folder:
cd /c/DockerProjects/Redis

    FROM redis:latest
CMD ["redis-server"]

     docker build -t redisnew  .
docker run --name myredisnew -d redisnew
docker ps
docker stop myredisnew
docker login
docker ps -a
 docker commit 0e993d2009a1 budarajumadhurika/redis1 
// Note 0e993d2009a1 is container id of myredisnew
 docker push budarajumadhurika/redis1
 docker rm 0e993d2009a1



ngrok config add-authtoken 34ejJvRYKqtjvBUEYEnxudIbpb7_33i6pYx8BJ2cZ1TpwasWq
ngrok http 8080


    
icacls "C:\path\to\your-key.pem" /inheritance:r
icacls "C:\path\to\your-key.pem" /grant:r "$($env:USERNAME):(R)"


AWS:    
sudo apt update 
    sudo apt-get install docker.io
    
    sudo docker build -t mymaven .
    sudo docker run -d -p 9090:8080 mymaven

    FROM tomcat:9-jdk11
    COPY **/*.war /usr/local/tomcat/webapps/

   
    <div id="root"></div>
    <script type="module" src="/src/main.jsx"></script>
  </body>
</html>

